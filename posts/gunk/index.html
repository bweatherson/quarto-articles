<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.479">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="John Hawthorne">
<meta name="author" content="Brian Weatherson">
<meta name="dcterms.date" content="2004-11-01">
<meta name="description" content="We raise an objection to the idea that the world is gunky. Certain plausible sounding supertasks have implausible consequences if the world is made of gunk.">

<title>Online Articles - Brian Weatherson - Chopping up Gunk</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="https://use.typekit.net/uzz2drx.css">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Online Articles - Brian Weatherson</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://brian.weatherson.org"> <i class="bi bi-mortarboard" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/bweatherson.bsky.social"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chopping up Gunk</h1>
                  <div>
        <div class="description">
          <p>We raise an objection to the idea that the world is gunky. Certain plausible sounding supertasks have implausible consequences if the world is made of gunk.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">metaphysics</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-heading">Affiliations</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="https://www.acu.edu.au/research/our-research-institutes/dianoia-institute-of-philosophy/our-people/john-hawthorne">John Hawthorne</a> </p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              Dianoia Institute of Philosophy
            </p>
        </div>
        <div class="quarto-title-meta-contents">
      <p class="author"><a href="http://brian.weatherson.org">Brian Weatherson</a> </p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              University of Michigan
            </p>
        </div>
      </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 1, 2004</p>
      </div>
    </div>
    
      
      <div>
      <div class="quarto-title-meta-heading">Doi</div>
      <div class="quarto-title-meta-contents">
        <p class="doi">
          <a href="https://doi.org/10.5840/monist200487316">10.5840/monist200487316</a>
        </p>
      </div>
    </div>
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sections</h2>
   
  <ul>
  <li><a href="#appendix" id="toc-appendix" class="nav-link active" data-scroll-target="#appendix">Appendix</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>Atomism, the view that indivisible atoms are the basic building blocks of physical reality, has a distinguished history. But it might not be true. The history of physical science certainly gives many of us pause. Every time some class of objects appeared to be the entities that Newton had described as “solid, massy, hard, impenetrable, movable Particles” out of which “God in the Beginning formed Matter” <span class="citation" data-cites="Newton1952">(<a href="#ref-Newton1952" role="doc-biblioref">Newton 1952, 400</a>)</span>, further research revealed that these objects were divisible after all. One might be tempted to see that history as confirming Leibniz’ dismissal of atomism as a “youthful prejudice” .<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Perhaps material objects and their parts are always divisible. There are no extended atoms; nor are there point particles which compose material beings.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn1"><p><sup>1</sup>&nbsp;See ‘Nature Itself’ in <span class="citation" data-cites="Leibniz1998">(<a href="#ref-Leibniz1998" role="doc-biblioref">Leibniz 1998, 220</a>)</span>.</p></li><li id="fn2"><p><sup>2</sup>&nbsp;Cf Leibniz: ‘I hold that <em>matter</em> is essentially an <em>aggregate</em>, and consequently that it always has actual parts,’ in ‘Third Explanation of The New System,’ <span class="citation" data-cites="Leibniz1998">(<a href="#ref-Leibniz1998" role="doc-biblioref">Leibniz 1998, 193</a>)</span>.</p></li></div><p>When first presented with this hypothesis, our imaginations are quickly drawn to picturing the process whereby a quantity of such matter – call it gunk -- is chopped up into smaller and smaller pieces. Prima facie, there is nothing problematic here: insofar as such a process continues without end, the initial quantity gets resolves into smaller and smaller chunks with no limit to the diminution. But suppose this process is packed into an hour, as imagined by Jose <span class="citation" data-cites="Bernadete1964">Bernadete (<a href="#ref-Bernadete1964" role="doc-biblioref">1964</a>)</span> in his 1964 monograph Infinity:</p>
<blockquote class="blockquote">
<p>Take a stick of wood. In 1/2 minute we are to divide the stick into two equal parts. In the next 1/4 minute we are to divide each of the two pieces again into two equal parts. In the next 1/8 minute we are to divide each of the four pieces (for there are now four equal pieces) again into two equal parts, &amp;c.&nbsp;<em>ad infinitum</em> <span class="citation" data-cites="Bernadete1964">(<a href="#ref-Bernadete1964" role="doc-biblioref">Bernadete 1964, 184</a>)</span>.</p>
</blockquote>
<p>If matter is divisible without end there seems to be no conceptual obstacle to each of the divisions. Yet how are we to imagine the situation at the end of the hour, when the super-task (call it ‘super-cutting’) has been performed on a quantity of gunk?<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div class="no-row-height column-margin column-container"><li id="fn3"><p><sup>3</sup>&nbsp;What is important, of course, is that the sequence of separations occur: it does not matter whether some kind of super-sharp knife is responsible for them. In what follows, descriptions of cutting sequences can be replaced without loss of content by descriptions of separation sequences, leaving it open whether repulsive forces or chance events or knives or … are responsible for the separation sequence.</p></li></div><p>If there were extended atoms that were never annihilated, it is clear enough what would happen if some super-being undertook to perform super-cutting: the process would grind to a halt when insurmountably hard particles resisted the chopper.</p>
<p>If, meanwhile, there were point-sized particles that composed planes that were as thin as a line, it would be natural to picture the limit of the process as a sea of separated slivers, each devoid of finite extent along one dimension. As Benardete, notes, one might then redo super-cutting in order to finally resolve the original stick into a sea of “metaphysical motes” devoid of finite extent in any direction:</p>
<blockquote class="blockquote">
<p>At the end of the minute how many pieces of wood will we have laid out before us? Clearly an infinite number. If the original stick was twenty inches in length, one inch in width, and one inch in depth, what are the dimensions of the metaphysical chips into which the stick has been decomposed? Each chip will be one inch by one inch by one inch by – what? So prodigiously thin must each chip be that its value is certifiably less then any rational (or irrational) quantity. Let us now take up one of the metaphysical chips and decompose it further into an infinite number of metaphysical splinters. In 1/2 minute we shall divide the chip into two equal parts. Each pieces will be one inch by 1/2 inch. In the next 1/4 minute we shall divide each of the two pieces again into two equal parts, yielding four pieces each being one inch by 1/4 inch. In the next 1/8 minute we shall divide each of the four pieces again into two equal parts, &amp;c ad infinitum. At the end of the mute we shall have composed the metaphysical chip into metaphysical splinters. Each splinter will be one inch in length. Let us now take up one of the metaphysical splinters and break it down into an infinite number of metaphysical motes <span class="citation" data-cites="Bernadete1964">(<a href="#ref-Bernadete1964" role="doc-biblioref">Bernadete 1964, 184–85</a>)</span></p>
</blockquote>
<p>The number of cuts made on the stick, the chip and the splinter respectively is aleph zero. The number of chips, splinters and motes left at the end of each cutting process, meanwhile, is aleph one. (Think of numbering each piece in a super-cutting process by an infinite expansion of one’s and zero’s as follows: if it lay on the left of the first cut, the first numeral is a zero, if to the right, the first numeral is a one; it if lay on the left of one of the pieces that was divided at the second round of cutting its second numeral is a zero, if to the right a one; and so on. For each decimal expansion of one’s and zero’s there is a bit and the end with that expansion.). This result is surprising to some, but poses no deep conceptual confusion. With an ontology of chips, splinters and motes available to us, there is a natural description available to us of the limit to the super-cutting processes described.</p>
<p>But what to say when gunk is subjected to super-cutting? If each quantity of matter has proper parts, then a sea of metaphysical motes is not, it would seem, an available outcome. In what follows, we unpack this puzzle, providing along the way some a priori physics for gunk-lovers. The problem is only well formed when we make explicit some of the assumptions that drive it. We do so below:</p>
<blockquote class="blockquote page-columns page-full">
<ol type="1">
<li>Gunk</li>
</ol>
<p>Every quantity of matter has proper parts.</p>
<ol start="2" type="1">
<li>Conservation of Matter:</li>
</ol>
<p>No mereological sum of quantities of matter can be destroyed by any sequence of cuts (though it may be scattered)<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<div class="no-row-height column-margin column-container"><li id="fn4"><p><sup>4</sup>&nbsp;The ‘can’ here is one of nomological possibility.</p></li></div><ol start="3" type="1">
<li>Occupation</li>
</ol>
<p>If a quantity of matter occupies a point of space, then there is some volume, extended in all dimensions, to which that point belongs which that quantity of matter occupies.</p>
<ol start="4" type="1">
<li>Super-cutting</li>
</ol>
<p>The laws of the world permit super-cutting.</p>
</blockquote>
<p>Note that (1), the thesis that every quantity of matter has parts does not, by itself, entail any of the other theses. One might also think that matter sometimes vanishes as a result of some sequence of cuts, denying (2). One might hold that there are metaphysical splinters (and perhaps even chips), denying (3). One might hold that any given quantity of matter does have point sized pieces but that those pieces themselves have parts (the parts being of the same size as the whole in this case), denying (3). One might hold that some pieces of gunk can occupy, say, a spherical region and also a single isolated point at some considerable distance from the spherical region (while maintaining that no part of it merely occupies the point), also denying (3). One might imagine that while always having parts, the parts below a certain thickness are inseparable, denying (4). One might think there is a minimum amount of time that any event of separation takes, also denying (4) and so on.</p>
<p>If the gunk hypothesis is maintained, but one or more of (2) to (4) is jettisoned, there is no problem left to solve. For example: If we are allowed to suppose that gunk may vanish, then it will be perfectly consistent to say that nothing is left at the limit of super-cutting. If we are allowed parts that lack finite extent, then it will be consistent to adopt Benardete’s picture of the outcome. And so on. Our puzzle, properly formulated is: What would happen if super-cutting occurred in a world where (1) to (4) are true?</p>
<p>In order to answer that question, we need to supplement Bernadete’s brief discussion of the super-cutting process. It is not immediately clear from what he says that super-cutting a piece of wood will turn an object into chips, even assuming the wood to be composed of point particles. That is a natural description of the limit of the process, but it is hardly one that is forced upon us by the barebones description of the process that Benardete provides. When we divide the stick into two pieces, and then into four pieces, where are we to put these pieces? Presumably we must ensure that they are separated. If not, it will not be clear that we really have splinters left at the end. If the stick is cut into four, but the four pieces are then stored so closely together that they are not scattered any more, then we will not have four scattered objects after two rounds of cutting. By extension, unless we separate the pieces sufficiently after each round (or at least after sufficiently many of them) then even in a world where matter is composed of point particles, it is not clear that there will be infinitely many chips left at the end. Note in this connection that there are limits as to how far we can separate the objects. In a world where super-cutting produces chips, we could not, from left to right, put a one inch gap between each chip and any other, since there are aleph one chips and not aleph one inches of space along any vector. Nor is it even clear what kind of spacing will do the trick: how we are to keep aleph one chips separated from each other? What we need is a formal model showing how super-cutting is to be performed. Only then can we answer with any precision what would happen were super-cutting to be performed on gunk.</p>
<p>Assume, for simplicity, that we have a stick that is exactly one inch long. At the first stage, cut the stick into two 1/2 inch long pieces, move the left-hand one 1/4 inch leftwards and the right hand one 1/4 inch rightwards. This can be accomplished in 1/2 second without moving the objects at a speed of faster than 1 inch per second, or accelerating or decelerating the objects at a rate higher than 4 inches per second per second.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> At the second stage, cut each piece into two, and move each of the left-hand pieces 1/16 of an inch leftwards, and each of the right-hand pieces 1/16 of an inch rightwards. So if the original piece occupied the interval [0,&nbsp;1) on a particular axis, the four pieces will now occupy the intervals: [-5/16, -1/16), [1/16, 5/16), [11/16, 15/16), [17/16, 21/16). (The reason we are using these half-open intervals is to avoid questions about whether the objects that are separated by the cut used to overlap.) This cutting and moving can be accomplished in 1/4 of a second, without any piece attaining a velocity higher than 1/2 inch per second, or an acceleration higher than 4 inches per second per second.</p>
<div class="no-row-height column-margin column-container"><li id="fn5"><p><sup>5</sup>&nbsp;The idea is that in the first quarter second we accelerate the object at 4 inches per second per second. This will raise its velocity to 1 inch per second, and move the object 1/8 of an inch. In the second quarter second we decelerate it at 4 inches per second per second, so its velocity ends up at zero, and it ends up having moved 1/4 of an inch.</p></li><li id="fn6"><p><sup>6</sup>&nbsp;Note that, interestingly, if we moved the pieces 1/2 inch after the first round, 1/4 inch after the second round, 1/8 inch after the third round and so on then at the limit, each left and right edge that was once attached will have moved back together again. The process we have chosen preserves separation in a way that the aforementioned process does not.</p></li></div><p>The third stage of the cutting is to take each of these four pieces, cut them in two, move the left-hand part of each of the four 1/64 of an inch to the left, and the right-hand part 1/64 of an inch to the right. So the eight pieces now occupy the intervals: [-21/64, -13/64), [-11/64, -3/64), [3/64, 11/64), [13/64,&nbsp;21/64), [43/64,&nbsp;51/64), [53/64,&nbsp;61/64), [67/64,&nbsp;75/64), [77/64,&nbsp;85/64). Again, this cutting and moving can be accomplished within 1/8 of a second, without any piece attaining a velocity higher than 1/4 inch per second, or an acceleration higher than 4 inches per second per second.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>In general, at stage <em>n</em>, we take the 2<em><sup>n</sup></em> pieces, divide each of them in two, move the left-hand piece 1/2<sup>2</sup><em><sup>n</sup></em> inches leftward, and the right-hand piece 1/2<sup>2</sup><em><sup>n</sup></em> inches rightward. This can all be done in 1/2<em><sup>n</sup></em> seconds without any piece attaining a velocity higher than 1/2<em><sup>n</sup></em><sup>-1</sup> inches per second, or an acceleration higher than 4 inches per second per second. So the whole super-cut can be performed in 1 second: the first stage in 1/2 second, the second stage in 1/4 second, the third stage in 1/8 second, and so on. Note, moreover, that the whole super-cut can be performed in a second without the pieces ever moving at any huge velocity. If readers doubted the possibility of super-cutting because they believed it to be a necessary truth that no matters travels at or beyond the speed of light, their doubts were misplaced: no piece of matter in the super-cutting process approaches a superluminous velocity.</p>
<p>Further, in this kind of procedure, a quantity of matter that is scattered during the super-cutting process remains scattered during the process. To see this, first consider a particular example. We noted above that at the second stage there were pieces occupying the intervals [-5/16, -1/16) and [1/16, 5/16). Before this, the point 0 had been occupied; at this stage a gap of 1/8 inch around 0 had been opened. This gap keeps being closed at each stage. After the third stage there were pieces occupying the intervals [/64, -3/64), [3/64, 11/64), so the gap is now only 3/32 inch. After the fourth stage, there will be pieces at [-27/256, -11/256), [11/256, 27/256), so the gap is now only 11/128 inch. This process will make the gap ever smaller, but will not lead to its closure. As the process continues, the size of the gap will approach 1/12 of an inch, but never cross that boundary. To see this, note that the size of the gap in inches after stage <em>n</em> (<em>n</em>&nbsp;<span class="math inline">\({\geq}\)</span> 3) is 1/8&nbsp;-&nbsp;1/2<sup>5</sup>&nbsp;-&nbsp;1/2<sup>7</sup>&nbsp;-&nbsp;…&nbsp;-&nbsp;1/2<sup>2</sup><em><sup>n</sup></em>. The sum of the series 1/2<sup>5</sup>&nbsp;+&nbsp;1/2<sup>7</sup>&nbsp;+&nbsp;…&nbsp;is 1/24. Hence the gap at stage <em>n</em> is greater than 1/8&nbsp;-&nbsp;1/24&nbsp;=&nbsp;1/12. So once the pieces around 0 have been separated, they will never be rejoined.</p>
<p>This result applies generally to all of the separated pieces in the super-cut. Once a gap is created, parts of pieces from either side of the gap are moved ever closer to the centre of the gap at every subsequent stage of the super-cut. But since we decrease the distance moved by each piece at each stage of the cut, and in particular decrease it by a factor greater than 2, the pieces, once disjointed, will never be united.</p>
<p>How is the matter arranged at the end of the super-cut? To answer this question we need to assume that motion is continuous. For each part of the object we can calculate its position function, the function from the length of time the super-cut has been in progress to the position of the part. At least, we can calculate this for all times until the end of the super-cut. With the continuity assumption in place we can infer that its position at the end of the cut is the limiting value of its position function. So we make this assumption.</p>
<p>We assumed above that there is a Cartesian axis running along the object; say that a part <em>a</em> covers a point <em>x</em> just in case <em>a</em> occupies some region [<em>y</em>, <em>z</em>), and <em>y</em>&nbsp;<span class="math inline">\({\leq}\)</span>&nbsp;<em>x</em> and <em>z</em>&nbsp;&gt;&nbsp;<em>x</em>. When we say <em>a</em> occupies [<em>y</em>, <em>z</em>), we do not mean to imply it occupies only that region, just that it occupies at least that region. Assume then that a part <em>a</em> occupies a point <em>x</em> (0&nbsp;<span class="math inline">\({\leq}\)</span>&nbsp;<em>x</em>&nbsp;&lt;&nbsp;1), and that the binary representation of <em>x</em> is 0.<em>x</em><sub>1</sub><em>x</em><sub>2</sub>…<em>x<sub>n</sub></em>…, where for each <em>x<sub>i</sub></em>, <em>x<sub>i</sub></em> equals 0 or 1, and for all <em>i</em>, there exists a <em>j</em> &gt; <em>i</em> such that <em>x<sub>j</sub></em>&nbsp;equals zero.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> If <em>x</em><sub>1</sub>&nbsp;=&nbsp;1, then <em>x</em>&nbsp;<span class="math inline">\({\geq}\)</span>&nbsp;1/2, so the some part of <em>a</em>, a small part that originally covered <em>x</em>, will be moved rightward at the first stage. It is possible that <em>a</em> itself may be split by the cut, but there will be a small part around <em>x</em> that is not split, and it will move rightward. If <em>x</em><sub>1</sub>&nbsp;=&nbsp;0, then <em>x</em>&nbsp;&lt;&nbsp;1/2, so some part of <em>a</em>, a small part that originally covered <em>x</em>, will be moved leftward at the first stage. Indeed, in general some part of <em>a</em>, a small part that originally covered <em>x</em>, will be moved rightward at the <em>n</em>’th stage if <em>x<sub>n</sub></em>&nbsp;=&nbsp;1, and some part of <em>a</em>, a small part that originally covered <em>x</em>, will be moved leftward at the <em>n</em>’th stage if <em>x<sub>n</sub></em>&nbsp;=&nbsp;0.</p>
<div class="no-row-height column-margin column-container"><li id="fn7"><p><sup>7</sup>&nbsp;The final condition is important to rule out numbers having two possible representations. For example, we have to choose whether the representation of 1/2 should be 0.1000… or 0.0111…, and we somewhat arbitrarily, choose the former.</p></li></div><p>Using the fact that a part gets moved 2<sup>-2</sup><em><sup>n</sup></em> inches at stage <em>n</em>, we can infer that after <em>n</em> stages, a small part that originally covered <em>x</em> and has not been split by the cuts will cover the following point after <em>n</em> cuts. <span class="math display">\[x + \frac{(-1)^{x_1 + 1}}{4} + \frac{(-1)^{x_2 + 1}}{16} + \dots + \frac{(-1)^{x_n + 1}}{2^{2n}}\]</span></p>
<p>Assuming continuity of motion, we can assume that <em>a</em> will end up with a part that eventually covers the following point, which we will call <em>f</em>(<em>x</em>). <span class="math display">\[f(x) = x + \sum_{i=1}^{\infty}\frac{(-1)^{x_i + 1}}{2^{2i}}\]</span></p>
<p>From this, it follows immediately that for all <em>x</em> in [0, 1), <em>f</em>(<em>x</em>) will end up being occupied. It turns out that these are the <em>only</em> points that are occupied at the end of the super-cut.</p>
<p>Assume that a point <em>y</em> is occupied at the end of the super-cut. We will construct a number <em>c</em> such that <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>c</em>). Recall that we noted above that whenever two pieces were separated, a gap was created between them that would never be completely filled. While parts of the stick would move closer and closer to the centre of that gap during the super-cut, the middle two-thirds of the gap would never be reoccupied. That interval, that would never be reoccupied, would be <em>liberated</em>. The interval [1/3, 2/3) is liberated at the first stage, the intervals [-1/24, 1/24) and [23/24, 25/24) are liberated at the second stage, the intervals [-37/192, -35/192), [35/192, 37/192), [155/192, 157/192) and [227/192, 229/192) are liberated at the third stage, and so on. If <em>y</em> is occupied, then <em>y</em> must not be in any liberated interval. Therefore it must be either to the left or to the right of any interval that is liberated.</p>
<p>Let <em>c</em><sub>1</sub>&nbsp;equal&nbsp;0 if <em>y</em> is to the left of the first liberated interval, [1/3, 2/3), and 1 otherwise. Given the value of <em>c</em><sub>1</sub>, it is already determined which side <em>y</em> is of one of the intervals liberated at the second stage. If <em>y</em> is to the left of [1/3, 2/3), for example, then it is to the left of [23/24, 25/24). But the value of <em>c</em><sub>1</sub> does not determine which side <em>y</em> is of the other interval. Let <em>c</em><sub>2</sub> equal 0 if <em>y</em> is to the left of that interval, and 1 otherwise. The values of <em>c</em><sub>1</sub> and <em>c</em><sub>2</sub> determine which side <em>y</em> is of three of the four intervals liberated at the fourth stage, but leave open which side it is of one of these four. Let <em>c</em><sub>3</sub> equal 0 if <em>y</em> is to the left of that interval, 1 otherwise. If we repeat this procedure for all stages, we will get values of <em>c<sub>i</sub></em> for all <em>i</em>. Let <em>c</em> be the number whose binary expansion is 0.<em>c</em><sub>1</sub><em>c</em><sub>2</sub>…<em>c<sub>n</sub></em>…. It follows that <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>c</em>). The reason once it is determined which side <em>y</em> is of each of the liberated intervals, <em>y</em> has been determined to fall in an interval that is exactly one point wide, and <em>f</em>(<em>c</em>) is in that interval, so <em>f</em>(<em>c</em>) must equal <em>y</em>. So <em>y</em> is occupied iff for some <em>x</em>, <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>x</em>). Say <em>S</em>&nbsp;=&nbsp;{<em>y</em>:&nbsp;<span class="math inline">\({\exists}\)</span><em>x</em>&nbsp;(<em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>x</em>))}; the conclusion is that all and only the points in <em>S</em> are occupied.</p>
<p>Could a piece of gunk occupy the points in <em>S</em>? Not given the assumptions we have made so far. <em>S</em> has two properties that might not seem consistent at first glance. It is <em>dense</em> in the sense that for any point <em>y</em> in <em>S</em>, and any distance <span class="math inline">\({\delta}\)</span>, there is another point <em>z</em> in <em>S</em> such that <em>y</em>&nbsp;-&nbsp;<em>z</em>&nbsp;&lt;&nbsp;<span class="math inline">\({\delta}\)</span>. But it is <em>disconnected</em> in the sense that for any two points <em>y</em> and <em>z</em> in <em>S</em>, there is an extended region <em>r</em> between <em>y</em> and <em>z</em> that is wholly unoccupied. The proofs of density and disconnectedness are given in the appendix.</p>
<p>Given (3), disconnectedness is inconsistent with gunk occupying <em>S</em>. If a material object occupies <em>S</em>, it must occupy the points in <em>S</em>. Let <em>y</em> be any one of these points. By (3), <em>S</em> must occupy some extended region containing <em>y</em>, say, [<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>). Two cases to consider. First case: <em>y</em><sub>1</sub>&nbsp;&lt;&nbsp;<em>y</em>. If [<em>y</em><sub>1</sub>,&nbsp;<em>y</em><sub>2</sub>)&nbsp;<span class="math inline">\({\subset}\)</span> <em>S</em>, then <em>y</em><sub>1</sub> and <em>y</em> are in <em>S</em>, and so are all the points in between them. Since the object occupies <em>S</em>, it follows that these points are occupied. Hence there is no extended region between <em>y</em><sub>1</sub> and <em>y</em> that is wholly unoccupied, which is inconsistent with disconnectedness. Second case: <em>y</em><sub>1</sub>&nbsp;=&nbsp;<em>y</em>. Again, [<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>) <span class="math inline">\({\subset}\)</span>&nbsp;<em>S</em>, and since this interval is non-empty, <em>y</em><sub>2</sub>&nbsp;&gt;&nbsp;<em>y</em><sub>1</sub>. Hence (<em>y</em><sub>1</sub> +&nbsp;<em>y</em><sub>2</sub>)&nbsp;/&nbsp;2 is greater than <em>y</em><sub>1</sub>, and all the points between it and <em>y</em><sub>1</sub> are occupied. This is also inconsistent with disconnectedness. So given (3), no material object could occupy <em>S</em>.</p>
<p>In summary, (1) through (4) plus continuity of motion cannot be true together. From (1), (2), and (4), we inferred that our super-cutting process was possible, and that it would not destroy any quantity of matter (though of course it would scatter it). Assuming continuity of motion, we calculated which points would be occupied after the super-cut. By (3) we concluded that no piece of gunk could occupy those points, or indeed any subset of them, yielding an inconsistent result. Suppose that the continuity of motion thesis is dropped. We can then maintain (1) to (4) with consistency. One should note, however, that a world where (1) to (4) holds would be a strange world indeed: if super-cutting is performed, the pieces of gunk would have to jump location at the limit. The gunk cannot occupy S: but in order to occupy a different set of points, various quantities of matter would have to jump position at the limit.</p>
<p>If one believes in gunk one has a choice: Abandon one or more of (2) to (4) or else deny that it is nomologically necessary that motion be continuous. Which assumption should be dropped? We leave it to the gunk lover to select the most tolerable package. The choice for the gunk lover is a little unenviable. Those who are attracted to the view that the actual world is gunky are very much wedded to (1) and (3). When philosophers take seriously the idea that that matter has parts all the way down<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>, they do not imagine conjoining that thesis with point sized parts, or else immaterial parts<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>, or else quantities of matter that are as thin as a plane, and so on. With a commitment to (1) and (3) in place, super-cutting will be loaded with physical significance. Accept that the laws of nature permits super-cutting and one will be committed to either denying the conservation of matter or the continuity of motion.</p>
<div class="no-row-height column-margin column-container"><li id="fn8"><p><sup>8</sup>&nbsp;See, for example, <span class="citation" data-cites="Zimmerman1996">(<a href="#ref-Zimmerman1996" role="doc-biblioref">Zimmerman 1996</a>)</span>.</p></li><li id="fn9"><p><sup>9</sup>&nbsp;Leibniz, with his monads, is an exception of course. No contemporary gunk lover wants a monadology, however.</p></li></div><section id="appendix" class="level3 unnumbered">
<h3 class="unnumbered anchored" data-anchor-id="appendix">Appendix</h3>
<p>To prove density, note that if <em>y</em> is occupied, there is a point <em>x</em> with binary representation 0.<em>x</em><sub>1</sub><em>x</em><sub>2</sub>… such that <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>x</em>). For any positive <span class="math inline">\({\delta}\)</span>, there is an integer <em>n</em> such that <span class="math inline">\({\delta}\)</span>&nbsp;&gt;&nbsp;2<sup>-2</sup><em><sup>n</sup></em>. Let <em>v</em> be the number represented by 0.<em>x</em><sub>1</sub><em>x</em><sub>2</sub>…<em>x<sub>n</sub>x<sub>n</sub></em><sub>+1</sub><span class="math inline">\(^\prime\)</span><em>x<sub>n</sub></em><sub>+2</sub><em>x<sub>n</sub></em><sub>+3</sub>…, where <em>x<sub>n</sub></em><sub>+1</sub><span class="math inline">\(^\prime\)</span>&nbsp;=&nbsp;1 iff <em>x<sub>n</sub></em><sub>+1</sub>&nbsp;= 0, and <em>x<sub>n</sub></em><sub>+1</sub><span class="math inline">\(^\prime\)</span>&nbsp;=&nbsp;0 otherwise. The difference between <em>f</em>(<em>x</em>) and <em>f</em>(<em>v</em>) will be exactly 2<sup>-2</sup><em><sup>n</sup></em><sup>-1</sup>. Since <em>f</em>(<em>v</em>) is occupied, and <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>x</em>), there is an occupied point exactly 2<sup>-2</sup><em><sup>n</sup></em><sup>-1</sup> inches from <em>y</em>, so there is a point less than <span class="math inline">\({\delta}\)</span> inches from <em>y</em>, as required.</p>
<p>To prove disconnectedness, let <em>y</em> and <em>z</em> be any two distinct occupied points. So for some distinct <em>v</em>,&nbsp;<em>x</em>, <em>y</em>&nbsp;=&nbsp;<em>f</em>(<em>x</em>) and <em>z</em>&nbsp;=&nbsp;<em>f</em>(<em>v</em>). Say that the binary representation of <em>x</em> is 0.<em>x</em><sub>1</sub><em>x</em><sub>2</sub>…, and the binary representation of <em>v</em> is 0.<em>v</em><sub>1</sub><em>v</em><sub>2</sub>… Let <em>j</em> be the lowest number such that <em>x<sub>j</sub></em>&nbsp;<span class="math inline">\({\neq}\)</span>&nbsp;<em>v<sub>j</sub></em>. (Since <em>x</em> and <em>v</em> are distinct, there must be at least one value <em>j</em>.) Without loss of generality, assume that <em>x<sub>j</sub></em>&nbsp;=&nbsp;0&nbsp;and <em>v<sub>j</sub></em>&nbsp;=&nbsp;1. (There is no loss of generality because we are just trying to show that between any two occupied points there is a gap, so it does not matter which of the two points is the rightward one.) Let <em>k</em> be the number with binary representation 0.<em>x</em><sub>1</sub><em>x</em><sub>2</sub>…<em>x<sub>j</sub></em>1, and let <em>l</em><sub>2</sub> be <em>f</em>(<em>k</em>). Finally, define <em>l</em><sub>1</sub> by the following equation: <span class="math display">\[l_i = \sum_{i=1}^j \frac{(-1)^{x_i+1}}{2^{2i}} + \sum_{i = j+1}^\infty \frac{1}{2^{2i}}\]</span></p>
<p>It is easy enough to see that <em>f</em>(<em>x</em>), that is <em>y</em>, must be less that <em>l</em><sub>1</sub>. For <em>l</em><sub>1</sub> is the value that <em>f</em>(<em>x</em>) would take were every digit in the binary expansion of <em>x</em> after <em>j</em> be 1. But by definition there must be some value <em>j</em><span class="math inline">\(^\prime\)</span>&nbsp;&gt;&nbsp;<em>j</em> such that <em>x<sub>j</sub></em><sub><span class="math inline">\(^\prime\)</span></sub>&nbsp;=&nbsp;0. From this it follows that: <span class="math display">\[\sum_{i = j+1}^\infty \frac{1}{2^{2i}} &gt; \sum_{i = j+1}^\infty \frac{(-1)^{x_i+1}}{2^{2i}}\]</span></p>
<p>And from that it follows that <em>l</em><sub>1</sub>&nbsp;&gt;&nbsp;<em>f</em>(<em>x</em>). Indeed, by similar reasoning, it follows that for all <em>u</em>&nbsp;&lt;&nbsp;<em>k</em>, <em>f</em>(<em>u</em>) &lt;&nbsp;<em>l</em><sub>1</sub>. Since <em>f</em> is monotone increasing, it also follows that for all <em>u</em>&nbsp;<span class="math inline">\({\geq}\)</span>&nbsp;<em>k</em>, <em>f</em>(<em>u</em>)&nbsp;<span class="math inline">\({\geq}\)</span>&nbsp;<em>l</em><sub>2</sub>. And from those facts, it follows that there does not exist a <em>u</em> such that <em>f</em>(<em>u</em>)&nbsp;<span class="math inline">\({\in}\)</span>&nbsp;[<em>l</em><sub>1</sub>,&nbsp;<em>l</em><sub>2</sub>). And since <em>y</em>&nbsp;&lt;&nbsp;<em>l</em><sub>1</sub>&nbsp;&lt;&nbsp;<em>l</em><sub>2</sub>&nbsp;<span class="math inline">\({\leq}\)</span>&nbsp;<em>z</em>, this implies that there is an extended unoccupied region between <em>y</em> and <em>z</em>, as required.</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Bernadete1964" class="csl-entry" role="listitem">
Bernadete, Jose. 1964. <em>Infinity: An Essay in Metaphysics</em>. Oxford: Clarendon Press.
</div>
<div id="ref-Leibniz1998" class="csl-entry" role="listitem">
Leibniz, Gottfried Wilhelm. 1998. <em>Philosophical Texts</em>. Translated by R. S. Woolhouse and Richard Francks. Oxford: Oxford University Press.
</div>
<div id="ref-Newton1952" class="csl-entry" role="listitem">
Newton, Isaac. 1952. <em>Opticks</em>. New York: Dover Press.
</div>
<div id="ref-Zimmerman1996" class="csl-entry" role="listitem">
Zimmerman, Dean. 1996. <span>“Could Extended Objects Be Made Out of Simple Parts: An Argument for Atomless Gunk.”</span> <em>Philosophy and Phenomenological Research</em> 56 (1): 1–29. <a href="https://doi.org/10.2307/2108463">https://doi.org/10.2307/2108463</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>