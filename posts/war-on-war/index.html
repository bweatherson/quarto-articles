<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.479">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Weatherson">
<meta name="dcterms.date" content="2021-11-15">
<meta name="description" content="A common argument for favoring Evidential Decision Theory (EDT) over Causal Decision Theory (CDT) is that EDT has predictably higher expected returns in Newcomb Problems. But this doesn’t show much. For almost any pair of theories you can come up with cases where one does, on average, better than the other. Here I describe three cases involving dynamic choice where EDT predictably does worse than CDT.">

<title>Online Articles - Brian Weatherson - A Dynamic WAR on EDT</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="https://use.typekit.net/uzz2drx.css">


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Online Articles - Brian Weatherson</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://brian.weatherson.org"> <i class="bi bi-mortarboard" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/bweatherson.bsky.social"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">A Dynamic WAR on EDT</h1>
                  <div>
        <div class="description">
          <p>A common argument for favoring Evidential Decision Theory (EDT) over Causal Decision Theory (CDT) is that EDT has predictably higher expected returns in Newcomb Problems. But this doesn’t show much. For almost any pair of theories you can come up with cases where one does, on average, better than the other. Here I describe three cases involving dynamic choice where EDT predictably does worse than CDT.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">games and decisions</div>
                <div class="quarto-category">unpublished</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="http://brian.weatherson.org">Brian Weatherson</a> </p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              University of Michigan
            </p>
        </div>
      </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 15, 2021</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Sections</h2>
   
  <ul>
  <li><a href="#example-one---split-newcomb" id="toc-example-one---split-newcomb" class="nav-link active" data-scroll-target="#example-one---split-newcomb"><span class="header-section-number">0.1</span> Example One - Split Newcomb</a></li>
  <li><a href="#example-two---coins-and-signals" id="toc-example-two---coins-and-signals" class="nav-link" data-scroll-target="#example-two---coins-and-signals"><span class="header-section-number">0.2</span> Example Two - Coins and Signals</a></li>
  <li><a href="#example-three---coins-and-newcomb" id="toc-example-three---coins-and-newcomb" class="nav-link" data-scroll-target="#example-three---coins-and-newcomb"><span class="header-section-number">0.3</span> Example Three - Coins and Newcomb</a></li>
  <li><a href="#why-the-examples-matter" id="toc-why-the-examples-matter" class="nav-link" data-scroll-target="#why-the-examples-matter"><span class="header-section-number">0.4</span> Why The Examples Matter</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>Here is a common form of argument against causal decision theory, as described by <span class="citation" data-cites="AhmedPrice2012">Ahmed and Price (<a href="#ref-AhmedPrice2012" role="doc-biblioref">2012</a>)</span>. (I’ve slightly changed some of the wording, but otherwise this argument is taken directly from page 16 of their paper.)</p>
<ol type="1">
<li>In Newcomb problems, the average returns to one-boxing exceed that to two-boxing.</li>
<li>Everyone can see that (1) is true.</li>
<li>Therefore one-boxing foreseeably does better than two-boxing. (by 1, 2)</li>
<li>Therefore Causal Decision Theory (CDT) is committed to the foreseeably worse option for anyone facing Newcomb’s problem.</li>
</ol>
<p>Here’s what they, and many other proponents of Evidential Decision Theory (EDT) say follows from 4.</p>
<blockquote class="blockquote">
<p>The point of the argument is that if everyone knows that the CDT-irrational strategy will in fact do better on average than the CDT-rational strategy, then it’s rational to play the CDT-irrational strategy. <span class="citation" data-cites="AhmedPrice2012">(<a href="#ref-AhmedPrice2012" role="doc-biblioref">Ahmed and Price 2012, 17</a>)</span></p>
</blockquote>
<p>This is what <span class="citation" data-cites="Lewis1981e">Lewis (<a href="#ref-Lewis1981e" role="doc-biblioref">1981</a>)</span> called the “Why Ain’cha Rich” argument, and what following <span class="citation" data-cites="Bales2018">Bales (<a href="#ref-Bales2018" role="doc-biblioref">2018</a>)</span> I’ll call the WAR argument. I’m going to argue this last step of the WAR argument doesn’t follow. Or, at the very least, that proponents of EDT cannot coherently say that it follows. For there are several cases where EDT foreseeably does worse than CDT. This paper will go over three of them.</p>
<section id="example-one---split-newcomb" class="level3" data-number="0.1">
<h3 data-number="0.1" class="anchored" data-anchor-id="example-one---split-newcomb"><span class="header-section-number">0.1</span> Example One - Split Newcomb</h3>
<p>This game takes place over three rounds. I’m calling the examples games from now on because, following <span class="citation" data-cites="Harper1986">Harper (<a href="#ref-Harper1986" role="doc-biblioref">1986</a>)</span>, I take it is best to think of the original Newcomb Problem as a game. The demon is an actor who considers what the other player is trying to do, and has incentives that explain their decision given their beliefs about the other player. In this case the incentive is to correctly predict what the other player does. That sounds like the demon is a player in a traditional game-theoretic setup. So I’ll make it explicit that that’s what the demon is. With that said, here is the three stage game.</p>
<p>At stage one, the human player chooses In or Out. If they choose Out, player gets 5 and demon gets 1. If they choose In, we move onto stage two.</p>
<p>At stage two, demon chooses Left or Right, and this choice is announced.</p>
<p>At stage three demon and the player simultaneously choose either Up or Down. Demon is very good at predicting what player’s choices will be, and indeed at stage two they were already very good at making such a prediction. And demon wants to use these predictive powers to get as high a payoff as possible, and this is common knowledge.</p>
<p>If demon chose Left at stage two, here is the payoff table at stage three. Player chooses the row, demon chooses the column, so between them they determine a cell, and in that cell I’ll list player’s payoff followed by demon’s payoff.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Up</th>
<th style="text-align: center;">Down</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Up</td>
<td style="text-align: center;">(2, 1)</td>
<td style="text-align: center;">(4, 0)</td>
</tr>
<tr class="even">
<td>Down</td>
<td style="text-align: center;">(1, 0)</td>
<td style="text-align: center;">(3, 3)</td>
</tr>
</tbody>
</table>
<p>If demon chose Right at stage two, here is the payoff table at stage three.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Up</th>
<th style="text-align: center;">Down</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Up</td>
<td style="text-align: center;">(12, 4)</td>
<td style="text-align: center;">(14, 0)</td>
</tr>
<tr class="even">
<td>Down</td>
<td style="text-align: center;">(11, 0)</td>
<td style="text-align: center;">(13, 2)</td>
</tr>
</tbody>
</table>
<p>In both games, the CDTer will choose Up, and the EDTer will choose Down. These are both fairly straightforward Newcomb Problems from players perspective, after all. In both games Up causally dominates Down, but Down will get a higher return if you assume, as we did assume, that demon mostly makes correct predictions.</p>
<p>So at stage two, demon will know that if the person facing them is an EDTer, they will get a return of 3 from Left and 2 from Right. (They’ll end up in the Down-Down cell either way.) So they will rationally choose Left. On the other hand, if the person facing them is a CDTer, they will get a return of 1 from Left and 4 from Right. (They’ll end up in the Up-Up cell either way.) So they will rationally choose Right. And everything in this paragraph can be deduced by a rational player at stage 1.</p>
<p>So at stage one, a CDTer will know that if they play In, they expect to get 12 (the game will go Right then Up-Up), and if they play Out, they know they’ll get 5. So they’ll play In. But an EDTer will know that if they play In, they expect to get 4 (the game will go Left then Down-Down), and if they play Out, they know they’ll get 5. So they’ll play Out.</p>
<p>The result of all this is that the CDTer will get 12, and the EDTer will get 5. So the CDTer will predictably do better than the EDTer. Indeed, the EDTer will voluntarily choose at stage one to take a lower payout than the CDTer ends up with. This seems bad for EDT, at least if we think that predictably ending up with a lower outcome is bad.</p>
<p>Now you might object that this is because at stage two the demon chooses to treat the EDTer differently to how they treat the CDTer. I don’t really agree for two reasons, though I’m not sure either of these reasons work. (Hence the second and third examples that are about to come.) One is that the demon isn’t trying to harm the EDTer; they are just trying to maximise their return. It so happens that EDT is such an impermissive theory that it doesn’t allow for any flexibility, and the demon, knowing this, is forced to take choices that are bad for EDT (and it turns out for the demon). But this isn’t the demon’s fault; it’s the fault of EDT being so impermissive. The other reason is that the demon does not in fact make any choices that hurt the EDTer. The EDTer should expect that the demon will in fact make such choices, in response to their theory, but that’s not quite the same thing. The only player who moves at all in the EDT version of the game is the player. So it’s a little hard to say this is just a case where the EDTer is harmed by the demon’s malicious choices.</p>
<p>I think those responses work, but I’m not completely sure that they do. So let’s look at a second example, one where the demon doesn’t have these variable payouts.</p>
</section>
<section id="example-two---coins-and-signals" class="level3 page-columns page-full" data-number="0.2">
<h3 data-number="0.2" class="anchored" data-anchor-id="example-two---coins-and-signals"><span class="header-section-number">0.2</span> Example Two - Coins and Signals</h3>
<p>This example is a version of a signaling game of the kind introduced by <span class="citation" data-cites="Lewis1969a">Lewis (<a href="#ref-Lewis1969a" role="doc-biblioref">1969</a>)</span>. And in particular it’s a version of the broadly adversarial kinds of signaling games that are central to the plot of <span class="citation" data-cites="ChoKreps1987">Cho and Kreps (<a href="#ref-ChoKreps1987" role="doc-biblioref">1987</a>)</span>. Again, it will involve three stages.</p>
<p>At the first stage a fair coin is flipped, and the result shown to the human player, but not the demon.</p>
<p>At the second stage, the human will choose Up or Down, and the choice will be publicly announced.</p>
<p>At the third stage, the demon will try to guess what the coin showed. The demon knows the payoff table I’m about to show you, and is arbitrarily good at predicting the human’s choice dispositions. That is, the demon can make accurate predictions of the form “If Heads, the human will make this choice, and if Tails, they will make that choice.”</p>
<p>The payoffs to each player are a function of what happens at each of the three steps, and are given by the following table.</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;">Coin</th>
<th style="text-align: center;">Human</th>
<th style="text-align: center;">Demon</th>
<th style="text-align: center;">Human Payoff</th>
<th style="text-align: center;">Demon Payoff</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">H</td>
<td style="text-align: center;">U</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">H</td>
<td style="text-align: center;">U</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">400</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">H</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">H</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">U</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">40</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">U</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">H</td>
<td style="text-align: center;">28</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">T</td>
<td style="text-align: center;">D</td>
<td style="text-align: center;">T</td>
<td style="text-align: center;">36</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<aside>
<p>Or as a picture,</p>
<p><img src="the-game.png" class="img-fluid" width="150"></p>
The lower case letters are for the players, ‘h’ for human and ‘d’ for demon. The upper case letters are for moves. The dotted lines mean that the demon doesn’t know which of these nodes is actual when a choice is needed.
</aside>
<p>The demon’s payoffs are just as you’d expect - they get rewarded iff they figure out how the coin landed. The human’s payoffs are more complicated, but the big thing to note is they get the biggest rewards if they manage to play Up while the demon makes an incorrect prediction.</p>
<p>One last thing about the demon before we analyse the game. If the demon predicts the human will do one thing if Heads and another if Tails, they will use the information from the human’s choice to make their guess about how the coin landed. But if they predict the human will say the same thing whether the coin landed Heads or Tails, they won’t know how the coin landed, and will flip their own coin to make a guess. So in that case it will be 50/50 whether the demon says Heads or Tails.</p>
<p>Onto the analysis. It should be fairly clear that if the coin lands Heads, the human should say Up. The worst possible return from Up is 40, the best possible return from Down is 0. This argument can be made a bit more rigorous, but I’ll leave that as an exercise for the reader, and just assume that that’s what both a CDTer and an EDTer would do, and hence what the demon would predict that they will do.</p>
<p>So what happens if the coin lands Tails? Given the demon will predict Up if Heads, we can work out the value of Up and Down if Tails to the EDTer. If they play Up, the demon will predict that, and hence the demon will flip a coin to choose Heads or Tails. So they have a 50/50 shot at getting either 40 or 28, and so their expected return is 34. If they play Down, the demon will predict that, and hence the demon will say Tails, and they will get a return of 36. Since 36 &gt; 34, they will play Down if Tails.</p>
<p>That’s the unique solution to the game for the EDTer. They play Up if Heads, Down if Tails. The demon can figure out that they’ll do this, so will correctly guess what the coin showed. And they will get 40 if the coin landed Heads, and 36 if it landed Tails, for an expected return of 38.</p>
<p>What should the CDTer do? Well it turns out that there are multiple solutions that are consistent with the general spirit of CDT. It’s consistent with CDT to do exactly what the EDTer does. But it’s also consistent to say Up no matter what. Let’s go over why this is consistent. The question is whether the CDTer can endorse their decision to play Up no matter what given each way the coin could land. They can clearly endorse it if the coin lands Heads; in that case Up strictly dominates Down, and the CDTer likes strictly dominant choices. What if the coin lands Tails? Well they think they’ll play Up. So they think the demon will flip a coin to guess in this situation. So they think the expected return of Up is 34 (like the EDTer thinks), and the expected return of Down is 32. The key difference here is that when working out the expected return of a non-chosen option, the CDTer does not change the expected behavior of the demon, while the EDTer does. (That’s what is needed to validate dominance reasoning.) So this CDTer will think that even if the coin lands Tails, they would do worse on average if they switched to playing Down if Tails. So it follows that they can consistently play Up either way.</p>
<p>And if they do play this, the rewards are handsome. The demon won’t have any information about the coin, so the demon will flip their own coin. So lines 1, 2, 5 and 6 of the table are all equally likely to appear. So this CDTer is equally likely to get a return of 40, 400, 40 or 28, for an overall expected return of 127. And this is much higher than the 38 the EDTer is expected to receive. By changing the payout on line 2, we can make the gap in expected returns be arbitrarily large.</p>
<p>Now you might object that while the CDTer can do better, it doesn’t follow from CDT alone that they will (on average) do better. After all, it is also consistent with CDT that the CDTer makes exactly the same plays as the EDTer. I don’t think that matters much. The point of the WAR is to refute a theory, and if the EDTer does foreseeably worse than one kind of CDTer, that should be enough to refute them. But just in case you think this objection is stronger, we’ll include one last example.</p>
</section>
<section id="example-three---coins-and-newcomb" class="level3" data-number="0.3">
<h3 data-number="0.3" class="anchored" data-anchor-id="example-three---coins-and-newcomb"><span class="header-section-number">0.3</span> Example Three - Coins and Newcomb</h3>
<p>This is just like Example Two, with one twist. If the game goes Tails, Down, Tails, then we don’t immediately end the game and make payouts to the players. Instead we play another game, with a familiar structure. As always, demon is really good at predicting human’s play, and the human payouts are listed first in every cell.</p>
<table class="table">
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;">Up</th>
<th style="text-align: center;">Down</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Up</td>
<td style="text-align: center;">(20, 1)</td>
<td style="text-align: center;">(40, 0)</td>
</tr>
<tr class="even">
<td>Down</td>
<td style="text-align: center;">(16, 0)</td>
<td style="text-align: center;">(36, 1)</td>
</tr>
</tbody>
</table>
<p>The EDTer will think they’ll get 36 from this game, so the example will be just like Example Two. And the EDTer will play Up if Heads, Down if Tails, for an expected return of 38.</p>
<p>But the CDTer will think that if the game gets to this stage, they’ll get 20. So now they think that in the original game, Up dominates Down no matter whether the coin lands Heads or Tails. So every CDTer will play Up no matter what, and get an expected return of 127.</p>
</section>
<section id="why-the-examples-matter" class="level3" data-number="0.4">
<h3 data-number="0.4" class="anchored" data-anchor-id="why-the-examples-matter"><span class="header-section-number">0.4</span> Why The Examples Matter</h3>
<p>I’m putting forward these examples not as part of a direct assault on EDT, but as a war on WAR. The point of the first example is that any theory whatsoever is subject to a WAR argument. That’s because for any theory whatsoever, you can construct pairs of choices like Left and Right, where the theory says to take choices that lead the demon to preferring to go Left. So for any theory whatsoever, or at least any theory that is consequentialist in the sense popularised by <span class="citation" data-cites="Hammond1988">Hammond (<a href="#ref-Hammond1988" role="doc-biblioref">1988</a>)</span>, there is an example where the theory leads to worse returns. So any consequentialist theory is subject to an objection by WAR. It’s the paradigm of an over-generating objection.</p>
<p>There is perhaps something a bit interesting about the second example, though it isn’t a problem especially for EDT. What makes the second example work is that the human player is in a situation that rewards unpredictability, but EDT is decisive, and hence predictable. By ‘decisive’ here, I mean it gives a clear verdict in cases that don’t involve ties. Of course, lots of theories are decisive, and hence the behavior of a chooser following such a theory is predictable. Sometimes it is thought to be a virtue of a decision theory that it is decisive, and gives clear advice about what to do in any situation. I’m not so sure. After all, for any such theory there will be a version of example two that can be constructed so as to raise a ‘problem’ for any such theory. Is this a problem for decisive theories, or a problem for the kind of WAR argument that we see in example two? Given how bad the other WAR arguments are, and given how popular decisive theories are, we should probably say this is a problem for WAR.</p>
<p>While this isn’t a direct assault on EDT, it is meant to raise doubts about it. If you think WAR is the intuitively strongest argument for EDT, and it turns out to be a bad argument, that’s not good news for EDT. But whether there is a way to rescue the motivations for EDT is a question for a different, and longer, paper. What I mean to have shown here is that WAR arguments are bad. They are arguments that every theory is bad, and arguments against every theory are successful arguments against no theory.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-AhmedPrice2012" class="csl-entry" role="listitem">
Ahmed, Arif, and Huw Price. 2012. <span>“Arntzenius on ‘Why Ain’cha Rich?’.”</span> <em>Erkenntnis</em> 77 (1): 15–30. <a href="https://doi.org/10.1007/s10670-011-9355-2">https://doi.org/10.1007/s10670-011-9355-2</a>.
</div>
<div id="ref-Bales2018" class="csl-entry" role="listitem">
Bales, Adam. 2018. <span>“Richness and Rationality: Causal Decision Theory and the WAR Argument.”</span> <em>Synthese</em> 195 (1): 259–67. <a href="https://doi.org/10.1007/s11229-016-1214-x">https://doi.org/10.1007/s11229-016-1214-x</a>.
</div>
<div id="ref-ChoKreps1987" class="csl-entry" role="listitem">
Cho, In-Koo, and David M. Kreps. 1987. <span>“Signalling Games and Stable Equilibria.”</span> <em>The Quarterly Journal of Economics</em> 102 (2): 179–221. <a href="https://doi.org/10.2307/1885060">https://doi.org/10.2307/1885060</a>.
</div>
<div id="ref-Hammond1988" class="csl-entry" role="listitem">
Hammond, Peter J. 1988. <span>“Consequentialist Foundations for Expected Utility.”</span> <em>Theory and Decision</em> 25 (1): 25–78. <a href="https://doi.org/10.1007/BF00129168">https://doi.org/10.1007/BF00129168</a>.
</div>
<div id="ref-Harper1986" class="csl-entry" role="listitem">
Harper, William. 1986. <span>“Mixed Strategies and Ratifiability in Causal Decision Theory.”</span> <em>Erkenntnis</em> 24 (1): 25–36. <a href="https://doi.org/10.1007/BF00183199">https://doi.org/10.1007/BF00183199</a>.
</div>
<div id="ref-Lewis1969a" class="csl-entry" role="listitem">
Lewis, David. 1969. <em>Convention: A Philosophical Study</em>. Cambridge: Harvard University Press.
</div>
<div id="ref-Lewis1981e" class="csl-entry" role="listitem">
———. 1981. <span>“Why Ain’cha Rich?”</span> <em>No<span>û</span>s</em> 15 (3): 377–80. <a href="https://doi.org/10.2307/2215439">https://doi.org/10.2307/2215439</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>