<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.479">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Weatherson">
<meta name="dcterms.date" content="2003-09-08">
<meta name="description" content="Review of Christopher Gauker, “Words Without Meaning”. Cambridge: MIT Press, 2002.">

<title>Online Articles - Brian Weatherson - Review of “Words Without Meaning”</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="https://use.typekit.net/uzz2drx.css">


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Online Articles - Brian Weatherson</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://brian.weatherson.org"> <i class="bi bi-mortarboard" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/bweatherson.bsky.social"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Review of “Words Without Meaning”</h1>
                  <div>
        <div class="description">
          <p>Review of Christopher Gauker, “Words Without Meaning”. Cambridge: MIT Press, 2002.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">book review</div>
                <div class="quarto-category">on books</div>
                <div class="quarto-category">language</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="http://brian.weatherson.org">Brian Weatherson</a> </p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              University of Michigan
            </p>
        </div>
      </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 8, 2003</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="review-of-words-without-meaning.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>In philosophy it’s hard to find a view that hasn’t had an <em>ism</em> associated with it, but there are some. Some theories are too obscure or too fantastic to be named. And occasionally a theory is too deeply entrenched to even be conceptualised as a theory. For example, many of us hold without thinking about it the theory that “the central function of language is to enable a speaker to reveal his or her thoughts to a hearer,” (3) that in the case of declarative utterances the thoughts in question are beliefs whose content is some proposition or other, and that hearers figure out what the content of that belief is by virtue of an inference that turns on their beliefs about the meanings of the words we use. These claims might seem too trivial to even be called a theory. They have seemed too trivial to draw an <em>ism</em>. Christopher Gauker calls them ‘the received view’, and the purpose of his book <em>Words Without Meanings</em> (all page references to this book) is to argue against this received view and propose an alternative theory in its place. In Gauker’s theory the primary function of language is social coordination. If language ever functions as a conduit to the mind, this is a secondary effect.</p>
<aside>
Published in <a href="https://ndpr.nd.edu/news/words-without-meaning/">Notre Dame Philosophical Reviews</a>.
</aside>
<p>It is useful to have an <em>ism</em> for everything, so let’s call ‘the received view’ <em>Lockism</em>, since Locke believed something similar. Of course, Locke probably didn’t have any detailed opinions about where the semantics/pragmatics distinction lies or what the role and importance Horn scales might be or how to build a compositional semantics for quantification, or indeed about many of the issues on which various contemporary Lockists have their most distinctive views, but there’s an intellectual legacy worth noting. Still, if Locke was a Lockist without having views on these matters, this starts to suggest how broad, and how divided, the Lockist church may be. Lockists need not agree on the semantic analyses of indicative conditionals or attitude reports. They need not even agree on whether there are such things as conventional implicatures or deep structures. An argument against Lockism will have to either focus on the few rather platitudinous points where Lockists agree, or try to respond to all the ways Lockists might develop their position. Gauker takes both options throughout his book. The central theses of the Lockist position that are attacked concern the nature and contents of beliefs, the nature of logical implication and the status of truth. Gauker’s attacks on Lockist theories of quantifier domain restriction and of presupposition rely more heavily on attacking all the variants of Lockism.</p>
<p>But the arguments against Lockism are not necessarily the most important parts of the book. Alongside the criticisms of Lockism, Gauker develops in great detail his own positive theory about the nature and role of linguistic communication. Gauker suggests “the primary function of assertions ... is to shape the manner in which interlocutors attempt to achieve their goals.” (52) Conversations do not take place in a vacuum. Conversants frequently talk because they want something. The world does not always make it easy for us to get what we want, but sometimes at least other people can tell us which ways work best.</p>
<p>It becomes crucial to Gauker’s theory here that certain actions are or are not in accord with certain sets of sentences. Given this idea the primary norm of conversation becomes: <em>Say things such that others who act in accord with what you say, and with what else has been said, will achieve their goals</em>. The concept of actions according with (sets of) sentences seems intuitive at first. If my goal is to download the new Matrix movie, then going to stealthatmovie.com is in accord with {‘The new Matrix movie is available at stealthatmovie.com’} while going to moviebootlegger.com, or anywhere else, is not. (These are, by the way, fake site names.) Given this idea of actions according with sets of sentences, we can then define the <em>context</em>, or set of relevant sentences, as the smallest set such that “all courses of action in accordance with it relative to the goal of the conversation are good ways of achieving the goal”. (56) We can then restate the primary norm as: <em>Say things that are in the context</em>. Those sentences will be useful to say, and their negations will be useful to deny. This idea of useful assertability becomes crucial to Gauker’s theory, often playing much the role that a Lockist has truth play. For example, validity gets defined in terms of assertability preservation in all contexts.</p>
<p>Clearly the concept of actions according with contexts given goals is quite crucial, but there’s less explication of it than we might hope. I have some idea what it might mean to say that my going to stealthatmovie.com accords with the <em>proposition</em> that the new Matrix movie is available at stealthatmovie.com, and I have some idea which facts in the world may make this true. But I don’t have as clear an idea about what it means to say this action accords with any <em>sentence</em>. Sentences are just marks on paper, or sound waves. We can be pretty sure that this accord between actions and marks on paper is not a <em>primitive</em> fact about the world. Lockists think that actions accord with sentences because sentences express propositions and some actions accord with propositions. But this isn’t Gauker’s account, and it isn’t clear what is. At one stage Gauker notes that the distinction between actions that accord with a context and those that do not will be primitive relative to the ‘fundamental norms of discourse’, which are the primary focus of <em>Words Without Meanings</em>. That sounds right, and I hope it’s a sign that we’ll see more details about the concept of accord in future work.</p>
<p>This issue though is important because there are a few reasons to worry about how the concept of accord will be explicated. First, whatever problems face Lockist theories of meaning, including some of the problems Gauker raises, may recur here. Second, some theories of accord will introduce entities that are functionally just like meanings, so if meaning is a functional concept, as seems plausible, those theories will not end up being theories of words without meaning. Third, as Gauker notes, there are serious epistemological questions about how we could ever learn which actions accord with which contexts relative to which goals. Those who are impressed by Fodor’s arguments for the systematicity of human linguistic competence will probably think these questions raise insuperable difficulty for anything like Gauker’s program. On the other hand, those that are impressed by Gauker’s program will probably find these Fodorian claims overstated.</p>
<p><em>Words Without Meaning</em> concludes with three chapters setting out a rather distinctive view of belief. Gauker argues that a complete account of the role of belief ascriptions should be sufficient for a theory of belief. This is not because of a general policy that explaining the talk about something is sufficient to explain the thing in general. Such a policy is not entirely antithetical to Gauker’s overall picture, but it would be hard to defend in all cases. Rather, Gauker argues, in practice we have little use for beliefs and desires other than in our ascriptions of them, so an account of their ascription is all the account we need. Many philosophers will baulk here, because they think folk psychology provides a crucial role for beliefs and desires. Since folk psychology is a crucial part of how we predict the actions of other people, and of how we explain their actions, there is an important aspect of the <em>nature</em> of beliefs and desires that a mere account of their ascriptions will not capture. These philosophers will not agree with Gauker that an “account of the attribution of beliefs and desires is already an account of [their] nature.” (271‑2)</p>
<p>Gauker’s response to these philosophers is to question the explanatory and predictive capacity of folk psychology. He argues first that the explanatory, and especially the predictive, power of folk psychology is much over-rather. And more importantly, he argues that when there do appear to be good folk psychological explanations or predictions, there are equally good explanations that do not appeal to beliefs and desires. The argument for this involves running through several cases with some care, but very roughly the common theme is that beliefs and desires (if they exist) are themselves capable of explanation, so at least most of the time we can replace an explanation in terms of beliefs and desires with one that appeals to the explanations of those very beliefs and desires. This gives us a fairly general strategy for dispensing with folk psychological concepts in explanation and prediction.</p>
<p>This does not mean that we adopt an error theory of belief or desire ascriptions. Gauker thinks these have a use, so they are properly assertable. Their role, in general, is to let us speak on behalf of other people. “The primary function of attributions of belief and desire is to extend the range of participation in conversation.” (226) When I say that Harry believes that tech stocks are good investments, I say <em>on Harry’s behalf</em> that tech stocks are good investments. Unfortunately, we never get a complete positive characterisation of when it is permissible to say something on Harry’s behalf. We are told that such assertions, like all assertions, must be relevant to the conversation, but beyond that not a lot. We are told that it can’t just be permissible to say this just in case Harry would be disposed to say it, were he here. Harry might have a habit of keeping his investment ideas to himself, but still believe that tech stocks are good investments. And we’re told that this can be permissible to say even if Harry has never made an ‘inner assertion’ that tech stocks are good investments. But this doesn’t amount to a positive characterisation. Further, it’s not clear how to extend this account to all attitude reports, especially reports of desire-like attitudes. One could truly say <em>Brian wants to play for the Red Sox</em>, but in doing so one is not making a command, or even a request, on my behalf.</p>
<p>As well as these intriguing positive proposals, there are several arguments against Lockism. Chapter 2, on mental representation, is an attack on the Lockist position that there are beliefs with propositional content. Gauker first notes that any attempt to provide an atomistic theory of mental content seems to run into insuperable counterexamples. The main focus is Fodor’s asymmetric dependence theory, but a few other atomist theories are raised and dismissed. Gauker suggests that holistic theories are a little more promising, but when we look at the details we see that these all fall to a version of Putnam’s model-theoretic argument. Gauker’s argument here differs from Putnam’s in two key respects. First, it concerns primarily mental content, rather than linguistic content. Second, it has fewer theoretical overheads. Gauker shows that the argument never really needed any complicated mathematics; the formalism in the standard semantics for first-order logic is quite sufficient. Despite those two differences, the argument is fairly familiar, and the moves that could be made in response are also, by now, fairly familiar. Gauker quickly surveys these moves, and notes why he thinks none of them work, but the survey will probably be too brief to convince many who are happy with their preferred reply to Putnam. Those who are not happy with any of the replies to Putnam, or who would be more impressed by a version of Putnam’s argument that did not drift into needless technicality, should enjoy Gauker’s argument.</p>
<p>The middle half of <em>Words Without Meanings</em> consists of six case studies designed to show that Gauker’s approach can solve problems that are intractable for Lockism. Three of these are described as being in pragmatics, the other three in semantics. Here Gauker more often has to revert to arguing against each of the different versions of Lockism in the literature, for there are few points of agreement among Lockists once we get to the details on how language works. This is particularly clear when we look at pragmatics. I guess most Lockists agree that there is a pragmatics/semantics distinction, and most of those who do agree think that there is such a thing as scalar implicature. Beyond that there are disagreements everywhere. So Gauker is more often required to argue against all the versions of Lockism in existence. Even if he succeeds against all of them, Lockism is a growing doctrine, and a smart Lockist could often take Gauker’s positive ideas and incorporate them into Lockism. So it’s not clear we’ll see any <em>knock-down</em> argument against Lockism here. But maybe there will be an interesting abductive argument develop, and in any case it is always worthwhile to see Gauker’s positive account. Space prevents a full discussion of many of the issues raised here, but I’ll provide a quick summary of the salient issues, and why Gauker thinks he has an advantage over his Lockist rivals.</p>
<p>The first case study concerns domains of discourse, which mostly means domains of quantification. To use Gauker’s example, imagine Tommy runs into Suzy’s room, where Suzy is playing with her marbles, and says “All the red ones are mine.” What determines the domain of Tommy’s quantifier? If it is what Tommy intends, then we might end up saying that his sentence is, surprisingly, true. For Tommy, it turns out, intends only to speak of the marbles in his room, which are as it turns out all his. But if we don’t take it to be what Tommy intends, and instead let the domain be set by what Suzy thinks the domain is, or what a reasonable hearer would think the domain is, then we undermine the Lockist picture that the role of language is for the <em>speaker’s</em> thoughts to be communicated. In these cases it is the thoughts of the hearer, or of a reasonable hearer, seem to determine the meaning of what is said. Gauker suggests it is better to say that the domain is the class of things that are relevant to the goal of the conversation that Tommy and Suzy are having.</p>
<p>The second case concerns presupposition. Allegedly, some sentences are such that they cannot be properly asserted or denied unless some condition, the presupposition, is met. Sentences containing factive attitude verbs are sometimes held to fall into this category. So I cannot affirm or deny <em>I regret that you failed the test</em> unless you failed the test. There are several Lockist theories of presupposition, but Gauker argues that none of them can satisfactorily explain how asserting such sentences can inform the hearer of the truth of the presupposition, in this case that the test was in fact failed. Gauker’s theory, which does not have a special category of truth conditions apart from assertability conditions, does not have this difficulty. For a similar reason, however, the Lockist theory that rejects the concept of presupposition also avoids any problem of informative presupposition.</p>
<p>The third case concerns Gricean implicature. Gauker notes, correctly, that we can well explain the effects of Gricean implicature without presuming that the hearer even contemplates what the speaker had in mind in speaking. But this kind of contemplation is essential to Grice’s official story. Gauker’s alternative suggestion is that we can explain non-literal communication by assuming the hearer draws inferences about the context from the assertability of what is actually said.</p>
<p>The next three case studies are classified as ‘Semantics’, so we might hope that here Lockists will present a more unified target. But two of the studies seem, from a Lockist perspective, to concern the semantics/pragmatics boundary, so again there will be several varieties of Lockism that need to be addressed.</p>
<p>The first semantics study concerns quantifiers. Gauker argues that in practice (1) is a bad argument form, (1a) for instance is invalid, while (2) is a good argument form.</p>
<ol type="1">
<li>Everything is F. Therefore, a is F. 1a. Everything is made of wood. Therefore, Socrates is made of wood.</li>
<li>a is F. Therefore, something is F.</li>
</ol>
<p>Gauker argues in some detail that various Lockist theories of quantifier domain restriction cannot explain the asymmetry here. On his theory, the asymmetry falls out quite naturally, since quantification is always over named objects, and once named an object is relevant. So (1) need not be valid, since a need not have been named, but (2) must be valid.</p>
<p>The last two case studies are the most interesting, and the most intricate. I can’t do justice in a small space to the details of Gauker’s theory, but I’ll say a little about the issues raised. Chapter 8 concerns conditionals. Gauker thinks he has a telling argument against a central Lockist claim. The primary intuition is that (3) and (4) are logically equivalent, i.e.&nbsp;each entails the other, (at least when p and q are not themselves conditionals), but they are not equivalent when embedded in longer sentences. In particular, (5) and (6) need not be equivalent.</p>
<ol start="3" type="1">
<li>Either not p or q</li>
<li>If p then q</li>
<li>Either not p or q, or r</li>
<li>If p then q, or r</li>
</ol>
<p>If this is right, then what Gauker calls ‘the Equivalence Principle’, that substitution of logical equivalent constituents preserves truth-conditional content, is false. Gauker suggests this is a serious problem for Lockism. There are, however, a few Lockist theories in which Equivalence fails. For example, in classical supervaluationism, p or not p is a logical truth, and p is equivalent to p is true, but p is true or not p is not a logical truth. So some Lockists have learned to live without Equivalence. More importantly, the data that suggests that (3) and (4) are logically equivalent isn’t unequivocal. Some Lockists have provided arguments as to why (3) and (4) will usually have the same assertion conditions even though they have different truth conditions. (Gauker notes Robert Stalnaker’s 1975 paper ‘Indicative Conditionals’ that argues for this line.) If those arguments can be made to succeed, then we can keep Equivalence by denying that (3) really <em>entails</em> (4).</p>
<p>More interesting than the possible Lockist replies is Gauker’s own theory. He manages, quite impressively I think, to provide a recursive definition of truth conditions for the connectives without keeping Equivalence. The rough idea is that <em>If p then q</em> is true iff p strictly implies q relative to the context. Strict implication theories usually block the inference from (5) to (6), as Gauker’s does, but they also normally block the inference from (3) to (4). In Gauker’s theory, however, because entailment is defined in terms of assertability-preservation, and disjunctions can only be asserted if one or other disjunct is assertable in every possibility left open by the context, the inference from (3) to (4) is valid. Roughly, any contextually salient possibility either contains not p or q, so all the possibilities that contain p contain q, in which case <em>If p then q</em> is assertable. This theory still has some counter-intuitive features, since the paradoxes of material implication are still with us, but it’s a fascinating addition to the literature on conditionals.</p>
<p>The final case study concerns truth, and in particular the semantic paradoxes. Gauker argues that extant Lockist responses to the paradoxes are not capable of handling metalinguistic versions of the paradox. In particular, Lockist theories struggle with sentences like (7).</p>
<ol start="7" type="1">
<li><ol start="7" type="1">
<li>does not express a true sentence in this context.</li>
</ol></li>
</ol>
<p>Gauker’s argument that his theory does better than the Lockist here has two parts. First, he has a detailed demonstration that it is impossible to infer a contradiction directly from (7) in his theory. Second, he argues that a Lockist explanation of what’s going on with (7) has to posit that uttering, or writing, ‘this context’ changes the context. This might be true, indeed Gauker endorses a similar claim in his response to the paradoxes. But on most Lockist accounts of what contexts are, we could replace the demonstrative with some other phrase that more directly picks out the context. For example if a context is just an ordered n-tuple, we could just replace ‘this context’ with a description of the n-tuple that is, actually, the context. Here it does look as if Gauker’s theory has more resources than the traditional Lockism. It remains to be seen whether Gauker’s theory is completely free from the paradoxes - it’s quite a bit harder to come up with a consistent theory of truth than it is to block the liar paradox - but again Gauker provides an interesting alternative to existing approaches, and one that experts in the area should pay close attention.</p>
<p>Overall, what should we make of <em>Words Without Meanings</em>? I think the book has three major aims, and it succeeds in two of them. The first aim is to extend Gauker’s preferred theory of linguistic communication to show how it handles presupposition, quantification, conditionals, attitude reports and truth ascriptions. In this it succeeds quite well, especially in showing how the project holds together technically. The second aim is to raise a host of problems for the Lockist theory, problems that are deserving of serious consideration and response. And again, there is no doubt it succeeds. Even if one thinks that all the problems Gauker raises can be solved, having them set forth so sharply certainly advances the debate. The third aim, the big one, is to convince Lockists that their research program is moribund, and Gauker’s contextualist alternative is the way of the future. That aim, in short, is for a revolution in semantics. (And in any fields that presuppose Lockist semantics. Many of our best syntactic theories have to be revised if Gauker is correct.) Here I think the book is less successful, if only because the aim is so high. It’s not clear how any short book, and the MIT series <em>Words Without Meaning</em> is in is clearly a series for short books, could trigger such a revolution. Lockism may have its weaknesses, and Gauker shines a spotlight on a few, but it’s been a relatively productive program the last fifty years, so overthrowing it will not be easy. Such a revolution would need a longer book, or books, answering among other questions the metaphysical and epistemological questions about Gauker’s concept of actions according with sentences we noted above. Gauker’s work always leaves the impression that he has worked through the relevant material in much more detail than is apparent from a superficial reading of the text, so such books and papers may well be in the pipeline. If one is already on Gauker’s side in these disputes, one should heartily welcome the wealth of detail <em>Words Without Meaning</em> adds to his program. If one is more conservative, more orthodox, one should perhaps be worried about the anomalies rising, but not panicked. At least, not panicked <em>yet</em>.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>