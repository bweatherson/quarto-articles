<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.479">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brian Weatherson">
<meta name="dcterms.date" content="2003-04-01">
<meta name="description" content="John Burgess has recently argued that Timothy Williamson’s attempts to avoid the objection that his theory of vagueness is based on an untenable metaphysics of content are unsuccessful. Burgess’s arguments are important, and largely correct, but there is a mistake in the discussion of one of the key examples. In this note I provide some alternative examples and use them to repair the mistaken section of the argument.">

<title>Online Articles - Brian Weatherson - Epistemicism, Parasites, and Vague Names</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link rel="stylesheet" href="https://use.typekit.net/uzz2drx.css">


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Online Articles - Brian Weatherson</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://brian.weatherson.org"> <i class="bi bi-mortarboard" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://bsky.app/profile/bweatherson.bsky.social"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Epistemicism, Parasites, and Vague Names</h1>
                  <div>
        <div class="description">
          <p>John Burgess has recently argued that Timothy Williamson’s attempts to avoid the objection that his theory of vagueness is based on an untenable metaphysics of content are unsuccessful. Burgess’s arguments are important, and largely correct, but there is a mistake in the discussion of one of the key examples. In this note I provide some alternative examples and use them to repair the mistaken section of the argument.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">logic</div>
                <div class="quarto-category">language</div>
                <div class="quarto-category">vagueness</div>
                <div class="quarto-category">notes</div>
              </div>
                  </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="http://brian.weatherson.org">Brian Weatherson</a> </p>
    </div>
      <div class="quarto-title-meta-contents">
          <p class="affiliation">
              University of Michigan
            </p>
        </div>
      </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">April 1, 2003</p>
      </div>
    </div>
    
      
      <div>
      <div class="quarto-title-meta-heading">Doi</div>
      <div class="quarto-title-meta-contents">
        <p class="doi">
          <a href="https://doi.org/10.1093/ajp/jag209">10.1093/ajp/jag209</a>
        </p>
      </div>
    </div>
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    <div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="epistemicism-parasites-and-vague-names.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>Why is it so implausible that there is a sharp boundary between the rich and the non-rich? Perhaps we find it implausible merely because we (implicitly) believe that if there were such a boundary we would be able to discover where it is. If this is so we should revise our judgements. As Timothy <span class="citation" data-cites="Williamson1994-WILV Williamson2000-WILKAI">Williamson (<a href="#ref-Williamson1994-WILV" role="doc-biblioref">1994</a>, <a href="#ref-Williamson2000-WILKAI" role="doc-biblioref">2000</a>)</span> has shown, if there were such a boundary we would <em>not</em> know where it is. Still, this is not the only reason for being sceptical about the existence of such a boundary. In “Vagueness, Epistemicism and Response-Dependence” John <span class="citation" data-cites="Burgess2001">Burgess (<a href="#ref-Burgess2001" role="doc-biblioref">2001</a>)</span> outlines an impressive objection to the existence of such boundaries, and in particular to epistemicist theories that posit their existence. Burgess’s objection is based not on principles about the <em>epistemology</em> of content, as the bad objection just stated is, but rather on principles about the <em>metaphysics</em> of content.</p>
<aside>
<p>Published in <em>Australasian Journal of Philosophy</em> 81: 276-279.</p>
Picture by <a href="https://www.flickr.com/photos/41059842@N03">Pacific Klaus</a> via <a href="https://search.creativecommons.org/photos/3dd50b73-bbb6-4184-b0c3-5cece916d9f9">Creative Commons</a>.
</aside>
<p>If a word <em>t</em> has content <em>c</em>, this must be the case in virtue of some more primitive fact obtaining. Facts about content, such as this, are not among the fundamental constituents of reality. Roughly, facts about linguistic content must obtain in virtue of facts about use. But there are simply not enough facts about use to determine a precise meaning for paradigmatically vague terms like ‘rich’. Any theory that holds that ‘rich’ does have a precise meaning must meet this objection. As Burgess argues, Williamson’s attempts to do this have not been entirely successful. Burgess argues, persuasively, that epistemicists owe us a theory of how terms like ‘rich’ get to have the precise meaning they apparently have given that the facts about use do not seem to generate a precise meaning. He also argues, less persuasively, that Williamson’s ‘parasitic’ strategy for meeting this obligation is unsuccessful. Indeed, the argument here rests at one point on a premiss that is clearly false. I will suggest a way to patch the argument and reinstate the objection to epistemicism.</p>
<p>The obligation to provide a theory that generates content in terms of use does not just fall on the epistemicists. We indeterminists about content must also discharge it. Assume that we have done so, and we have a theory of content that divides sentences into (at least) the true, the false and the indeterminate. <span class="citation" data-cites="Williamson1994-WILV">(<a href="#ref-Williamson1994-WILV" role="doc-biblioref">Williamson 1994, 207–8</a>)</span> argues that the only reason we believe that any sentences fall into this third category is that we are respecting a mythical symmetry between truth and falsity. We are falling into the trap of thinking that if a sentence is not somehow made false, it is not false. The true story is that if an assertoric sentence has content, and it is not made true, it is<em>false</em>. This provides the basis for Williamson’s ‘parasitic’ strategy: wait for the indeterminist to offer a theory of when sentences are true, accept that part of the indeterminist theory, and say all other sentences that express propositions are false. If the strategy works, then there is no way the indeterminist can meet the obligation to provide a theory of content without the epistemicist also being able to do so, so there is no argument for indeterminism here. (There are complications, to put it mildly, with this strategy when the indeterminist allows the border between the true and the indeterminate to be vague. Burgess lets these potential problems slide, and so shall I.)</p>
<p>The strategy rests on the purported asymmetry between truth and falsity. Burgess claims that positing such an asymmetry makes epistemicism inconsistent. Consider a colour patch that is around the border between red and orange. Burgess claims, correctly, that an indeterminist theory of content may say that (1) and (2) are indeterminate, and hence Williamson might be committed to the position that (1) and (2) are false, and hence so is (3).</p>
<ol type="1">
<li><p>That patch is red.</p></li>
<li><p>That patch is orange.</p></li>
<li><p>That patch is either red or orange.</p></li>
</ol>
<p>But this is hopeless because “on the epistemicist view, there is a sharp boundary in the series between red and orange; every patch is either one or the other.” <span class="citation" data-cites="Burgess2001">(<a href="#ref-Burgess2001" role="doc-biblioref">Burgess 2001, 519</a>)</span> This last claim is false. According to epistemicism, there is a sharp boundary between red and not red, so the patch is either red or not red. But the epistemicist need not hold that if the patch is not red, then it is orange. It is consistent with epistemicism that there are colours strictly between red and orange, just as it is consistent with epistemicism that there are colours strictly between red and yellow, and just as it is consistent with epistemicism that there are colours strictly between red and blue. Hence it is possible that the colour of this patch is strictly between red and orange, and thus is neither red nor orange. So this line of reasoning does not work. Perhaps the argument can be easily fixed. According to the indeterminist, both (1) and (4) are indeterminate. Hence according to Williamson’s ‘parasitic’ theory of content, both (1) and (4) are false, so (5) is false.</p>
<ol type="1">
<li><p>That patch is red.</p></li>
<li><p>That patch is not red.</p></li>
<li><p>That patch is either red or not red.</p></li>
</ol>
<p>This is more like a problem, because Williamson certainly is committed to the truth of (5). However, it is easy to see how Williamson should respond. The theory of content sketched above (or more precisely, the strategy for converting indeterminist theories to determinist ones) was only meant to apply to simple sentences. A <em>simple</em> sentence is true iff the indeterminist says it is true. The truth value of <em>compound</em> sentences, like (4) and (5), is given by a standard Davidsonian theory of truth. Hence (1) is false and (4) is true, as required.</p>
<p>The best way to resurrect Burgess’s argument is to shift our attention from vague predicates to vague names. Consider any mountain, say Kilimanjaro. It is vague just where the mountain starts, so it will be vague just which atoms constitute Kilimanjaro. Kilimanjaro is some fusion of atoms or other, but it is indeterminate just which one it is. Some of these fusions have different masses, and some have different shapes, so no sentence of the form of (6) or of (7) will be true according to the indeterminist.</p>
<ol start="6" type="1">
<li><p>Kilimanjaro has shape <em>s</em>.</p></li>
<li><p>Kilimanjaro has mass <em>m</em>.</p></li>
</ol>
<p>Hence according to the Williamson’s asymmetric theory of truth, any sentence of either of these forms is false. Note that this holds even if we restrict the application of his theory to simple sentences. Now let <em>K</em> be a set of fusions of atoms {<em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>, …, <em>f<sub>n</sub></em>} such that it is determinate that Kilimanjaro is one of these fusions. (Because of higher-order vagueness it may be impossible to find such a set that does not contain any fusion that is determinately not Kilimanjaro. That will not matter; all that we require is that Kilimanjaro is one of these fusions.) Let <em>s<sub>i</sub></em> be the shape of <em>f<sub>i</sub></em> and <em>m<sub>i</sub></em> its mass. Then for all <em>i</em>, (6.<em>i</em>) and (7.<em>i</em>) are false, as we just argued.</p>
<ol start="6" type="1">
<li><ol type="i">
<li>Kilimanjaro has shape <em>s<sub>i</sub></em>.</li>
</ol></li>
<li><ol type="i">
<li>Kilimanjaro has mass <em>m<sub>i</sub></em>.</li>
</ol></li>
</ol>
<p>Hence both (8) and (9) are false.</p>
<ol start="8" type="1">
<li><p>Kilimanjaro has shape <em>s</em><sub>1</sub> or Kilimanjaro has shape <em>s</em><sub>2</sub> or … or Kilimanjaro has shape <em>s<sub>n</sub></em>.</p></li>
<li><p>Kilimanjaro has mass <em>m</em><sub>1</sub> or Kilimanjaro has mass <em>m</em><sub>2</sub> or … or Kilimanjaro has mass <em>m<sub>n</sub></em>.</p></li>
</ol>
<p>And the epistemicist is committed to (8) and (9) being true. We may not be able to discover which disjunct is true, but that is no reason to think that the disjunction is not true. Burgess’s argument was that if we adopt Williamson’s advice for constructing a theory of content, we will misclassify sentences that express penumbral connections. He was basically right, but we need to use a different example to prove it.</p>
<p>I assumed above that Kilimanjaro is a fusion of atoms. Some may object to this on the grounds that Kilimanjaro has different temporal and modal properties to any fusion of atoms. I doubt such objections ultimately work, but for present purposes the important thing to note is that the argument can go through without such an assumption. Even if Kilimanjaro is not identical to any fusion in <em>K</em>, it is clear that Kilimanjaro (actually, now) exactly overlaps some member of <em>K</em>. And since Kilimanjaro has the same (actual, present) shape and mass as any fusion of atoms it exactly overlaps, it still follows that (8) and (9) are true.</p>
<p>If we do assume that Kilimanjaro is one of the fusions, then we can generate another case where Williamson’s theory generates false predictions. Since at most one of the fusions is a mountain, it follows that (10.<em>i</em>) is indeterminate for all <em>i</em> on an indeterminist theory of content, and hence false according to Williamson.</p>
<ol start="10" type="1">
<li><ol type="i">
<li><em>f<sub>i</sub></em> is a mountain.</li>
</ol></li>
</ol>
<p>Hence his theory mistakenly predicts that (11) is false, when it is by hypothesis true.</p>
<ol start="11" type="1">
<li><em>f</em><sub>1</sub> is a mountain or <em>f</em><sub>2</sub> is a mountain or … or <em>f<sub>n</sub></em> is a mountain.</li>
</ol>
<p>This argument does rest on a contentious bit of metaphysics, but it still seems basically sound.</p>
<p>I did not assume at any point that Kilimanjaro is a vague object. I did assume that ‘Kilimanjaro’ is a vague name, but it is consistent with the argument I have presented that there are no vague objects, and the vagueness in ‘Kilimanjaro’ consists in it being indeterminate which precise object it denotes.</p>
<p>As Burgess demonstrates, it is fair to require that the epistemicist provide a theory of how terms get the precise content they do. Williamson attempted to show he was in just as good a position to discharge this obligation as the indeterminist by providing an algorithm for converting any indeterminist theory of content into one acceptable to the epistemicist. Burgess argued that the algorithm produced unacceptable results when we applied it to vague sentences such as (1) and (2). This particular argument is no good; the algorithm does not seem to produce implausible results in that case. We can make this form of argument work, however, especially if we focus on vague names. Applying the algorithm to any plausible indeterminist theory produces the result that every disjunct in (8) and (9) are false, and hence that these disjunctions are false. Since the epistemicist is (correctly) committed to these sentences being true, Burgess was correct to conclude that “this particular attempt to implement the parasite strategy is doomed to failure.”</p>




<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Burgess2001" class="csl-entry" role="listitem">
Burgess, John. 2001. <span>“Vagueness, Epistemicism and Response-Dependence.”</span> <em>Australasian Journal of Philosophy</em> 79 (4): 507–24. <a href="https://doi.org/10.1080/713659306">https://doi.org/10.1080/713659306</a>.
</div>
<div id="ref-Williamson1994-WILV" class="csl-entry" role="listitem">
Williamson, Timothy. 1994. <em><span>Vagueness</span></em>. Routledge.
</div>
<div id="ref-Williamson2000-WILKAI" class="csl-entry" role="listitem">
———. 2000. <em><span class="nocase">Knowledge and its Limits</span></em>. Oxford University Press.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>